# HEADER_BEGIN

{{BEGIN_REPLACE}}

steptime = get_steptime()

textmsg("ExternalControl: steptime=", steptime)
MULT_jointstate = {{JOINT_STATE_REPLACE}}
MULT_time = {{TIME_REPLACE}}

STOPJ_ACCELERATION = 4.0

#Constants
SERVO_UNINITIALIZED = -1
SERVO_IDLE = 0
SERVO_RUNNING = 1

MODE_STOPPED = -2
MODE_UNINITIALIZED = -1
MODE_IDLE = 0
MODE_SERVOJ = 1
MODE_SPEEDJ = 2
MODE_FORWARD = 3
MODE_SPEEDL = 4
MODE_POSE = 5
MODE_SPLINE = 6

TRAJECTORY_MODE_RECEIVE = 1
TRAJECTORY_MODE_CANCEL = -1

TRAJECTORY_POINT_JOINT = 0
TRAJECTORY_POINT_CARTESIAN = 1
TRAJECTORY_POINT_JOINT_SPLINE = 2
TRAJECTORY_DATA_DIMENSION = 3*6 + 1

TRAJECTORY_RESULT_SUCCESS = 0
TRAJECTORY_RESULT_CANCELED = 1
TRAJECTORY_RESULT_FAILURE = 2

ZERO_FTSENSOR = 0
SET_PAYLOAD = 1
SET_TOOL_VOLTAGE = 2
SCRIPT_COMMAND_DATA_DIMENSION = 5

CUBIC_SPLINES = 0
QUINTIC_SPLINES = 1

#Global variables are also showed in the Teach pendants variable list
global cmd_servo_state = SERVO_UNINITIALIZED
global cmd_servo_qd = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
global cmd_servo_q = get_actual_joint_positions()
global cmd_servo_q_last = get_actual_joint_positions()
global cmd_twist = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
global extrapolate_count = 0
global extrapolate_max_count = 0
global control_mode = MODE_UNINITIALIZED
global trajectory_points_left = 0
global last_spline_qdd = [0, 0, 0, 0, 0, 0]

def set_servo_setpoint(params_mult):
  cmd_servo_state = SERVO_RUNNING
  cmd_servo_q_last = cmd_servo_q
  cmd_servo_q = [params_mult[2], params_mult[3], params_mult[4], params_mult[5], params_mult[6], params_mult[7]] / MULT_jointstate
end

def extrapolate():
  diff = [cmd_servo_q[0] - cmd_servo_q_last[0], cmd_servo_q[1] - cmd_servo_q_last[1], cmd_servo_q[2] - cmd_servo_q_last[2], cmd_servo_q[3] - cmd_servo_q_last[3], cmd_servo_q[4] - cmd_servo_q_last[4], cmd_servo_q[5] - cmd_servo_q_last[5]]
  cmd_servo_q_last = cmd_servo_q
  cmd_servo_q = [cmd_servo_q[0] + diff[0], cmd_servo_q[1] + diff[1], cmd_servo_q[2] + diff[2], cmd_servo_q[3] + diff[3], cmd_servo_q[4] + diff[4], cmd_servo_q[5] + diff[5]]

  return cmd_servo_q
end

thread servoThread():
  textmsg("ExternalControl: Starting servo thread")
  state = SERVO_IDLE
  while control_mode == MODE_SERVOJ:
    enter_critical
    q = cmd_servo_q
    do_extrapolate = False
    if (cmd_servo_state == SERVO_IDLE):
      do_extrapolate = True
    end
    state = cmd_servo_state
    if cmd_servo_state > SERVO_UNINITIALIZED:
      cmd_servo_state = SERVO_IDLE
    end

    if do_extrapolate:
      extrapolate_count = extrapolate_count + 1
      if extrapolate_count > extrapolate_max_count:
        extrapolate_max_count = extrapolate_count
      end

      q = extrapolate()
      servoj(q, t=steptime, {{SERVO_J_REPLACE}})

    elif state == SERVO_RUNNING:
      extrapolate_count = 0
      servoj(q, t=steptime, {{SERVO_J_REPLACE}})
    else:
      extrapolate_count = 0
      sync()
    end
    exit_critical
  end
  textmsg("ExternalControl: servo thread ended")
  stopj(STOPJ_ACCELERATION)
end

# Helpers for speed control
def set_speed(params_mult):
  cmd_servo_qd = [params_mult[2], params_mult[3], params_mult[4], params_mult[5], params_mult[6], params_mult[7]] / MULT_jointstate
  control_mode = MODE_SPEEDJ
end

thread speedThread():
  textmsg("ExternalControl: Starting speed thread")
  while control_mode == MODE_SPEEDJ:
    qd = cmd_servo_qd
    speedj(qd, 40.0, steptime)
  end
  textmsg("ExternalControl: speedj thread ended")
  stopj(STOPJ_ACCELERATION)
end

def cubicSplineRun(end_q, end_qd, time):
  textmsg("cubicSplineRun time: ", time)
  # Zero time means zero length and therefore no motion to execute
  if time > 0.0:
    local start_q = get_target_joint_positions()
    local start_qd = get_target_joint_speeds()

    # Coefficients0 is not included, since we do not need to calculate the position
    local coefficients1 = start_qd
    local coefficients2 = (-3 * start_q + end_q * 3 - start_qd * 2 * time - end_qd * time) / pow(time, 2)
    local coefficients3 = (2 * start_q - 2 * end_q + start_qd * time + end_qd * time) / pow(time, 3)
    local coefficients4 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    local coefficients5 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    jointSplineRun(coefficients1, coefficients2, coefficients3, coefficients4, coefficients5, time)
  end
end

def quinticSplineRun(end_q, end_qd, end_qdd, time):
  # Zero time means zero length and therefore no motion to execute
  if time > 0.0:
    local start_q = get_target_joint_positions()
    local start_qd = get_target_joint_speeds()
    local start_qdd = last_spline_qdd

    # Pre-calculate coefficients
    local TIME2 = pow(time, 2)
    # Coefficients0 is not included, since we do not need to calculate the position
    local coefficients1 = start_qd
    local coefficients2 = 0.5 * start_qdd
    local coefficients3 = (-20.0 * start_q + 20.0 * end_q - 3.0 * start_qdd * TIME2 + end_qdd * TIME2 - 12.0 * start_qd * time - 8.0 * end_qd * time) / (2.0 * pow(time, 3))
    local coefficients4 = (30.0 * start_q - 30.0 * end_q + 3.0 * start_qdd * TIME2 - 2.0 * end_qdd * TIME2 + 16.0 * start_qd * time + 14.0 * end_qd * time) / (2.0 * pow(time, 4))
    local coefficients5 = (-12.0 * start_q + 12.0 * end_q - start_qdd * TIME2 + end_qdd * TIME2 - 6.0 * start_qd * time - 6.0 * end_qd * time) / (2.0 * pow(time, 5))
    jointSplineRun(coefficients1, coefficients2, coefficients3, coefficients4, coefficients5, time)
  end
end

def jointSplineRun(coefficients1, coefficients2, coefficients3, coefficients4, coefficients5, splineTotalTravelTime):
  # Initialize incremental time variable
  local splineTimerTraveled = 0.0

  # Interpolate the spline in hole time steps
  while (splineTotalTravelTime - splineTimerTraveled) > get_steptime():
    splineTimerTraveled = splineTimerTraveled + get_steptime()
    jointSplineStep(coefficients1, coefficients2, coefficients3, coefficients4, coefficients5, splineTimerTraveled, get_steptime())
  end

  # Last part of the spline which uses less than one time step
  local timeLeftToTravel = splineTotalTravelTime - splineTimerTraveled

  # To round off the float to the steptime step when it is very close to that number (1e-15)
  if timeLeftToTravel == get_steptime():
    timeLeftToTravel = get_steptime()
  end

  jointSplineStep(coefficients1, coefficients2, coefficients3, coefficients4, coefficients5, splineTotalTravelTime, timeLeftToTravel)
end

def jointSplineStep(coefficients1, coefficients2, coefficients3, coefficients4, coefficients5, splineTimerTraveled, timestep):
  local qd = coefficients1 + 2.0 * splineTimerTraveled * coefficients2 + 3.0 * pow(splineTimerTraveled, 2) * coefficients3 + 4.0 * pow(splineTimerTraveled, 3) * coefficients4 + 5.0 * pow(splineTimerTraveled, 4) * coefficients5
  last_spline_qdd = 2.0 * coefficients2 + 6.0 * splineTimerTraveled * coefficients3 + 12.0 * pow(splineTimerTraveled, 2) * coefficients4 + 20.0 * pow(splineTimerTraveled, 3) * coefficients5
  speedj(qd, 1000, timestep)
end

thread trajectoryThread():
  textmsg("Executing trajectory. Number of points: ", trajectory_points_left)
  local INDEX_TIME = TRAJECTORY_DATA_DIMENSION
  local INDEX_BLEND = INDEX_TIME + 1
  # same index as blend parameter, depending on point type
  local INDEX_SPLINE_TYPE = INDEX_BLEND 
  local INDEX_POINT_TYPE = INDEX_BLEND + 1
  last_spline_qdd = [0, 0, 0, 0, 0, 0]
  enter_critical
  while trajectory_points_left > 0:
    #reading trajectory point + blend radius + type of point (cartesian/joint based)
    global raw_point = socket_read_binary_integer(TRAJECTORY_DATA_DIMENSION+1+1, "trajectory_socket", get_steptime())
    trajectory_points_left = trajectory_points_left - 1
    
    if raw_point[0] > 0:
      local q = [ raw_point[1], raw_point[2], raw_point[3], raw_point[4], raw_point[5], raw_point[6]] / MULT_jointstate
      local tmptime = raw_point[INDEX_TIME] / MULT_time
      local blend_radius = raw_point[INDEX_BLEND] / MULT_time
      if trajectory_points_left > 0:
        # MoveJ point
        if raw_point[INDEX_POINT_TYPE] == TRAJECTORY_POINT_JOINT:
          movej(q, t=tmptime, r=blend_radius)

          # reset old acceleration
          last_spline_qdd = [0, 0, 0, 0, 0, 0]

        # Movel point
        elif raw_point[INDEX_POINT_TYPE] == TRAJECTORY_POINT_CARTESIAN:
          movel(p[q[0], q[1], q[2], q[3], q[4], q[5]], t=tmptime, r=blend_radius)

          # reset old acceleration
          last_spline_qdd = [0, 0, 0, 0, 0, 0] 

        # Joint spline point
        elif raw_point[INDEX_POINT_TYPE] == TRAJECTORY_POINT_JOINT_SPLINE:
          # Cubic spline
          if raw_point[INDEX_SPLINE_TYPE] == CUBIC_SPLINES:
            qd = [ raw_point[7], raw_point[8], raw_point[9], raw_point[10], raw_point[11], raw_point[12]] / MULT_jointstate
            cubicSplineRun(q, qd, tmptime)

            # reset old acceleration
            last_spline_qdd = [0, 0, 0, 0, 0, 0]

          # Quintic spline
          elif raw_point[INDEX_SPLINE_TYPE] == QUINTIC_SPLINES:
            qd = [ raw_point[7], raw_point[8], raw_point[9], raw_point[10], raw_point[11], raw_point[12]] / MULT_jointstate
            qdd = [ raw_point[13], raw_point[14], raw_point[15], raw_point[16], raw_point[17], raw_point[18]] / MULT_jointstate
            quinticSplineRun(q, qd, qdd, tmptime)
          end
        end
      # Last trajectory point
      else: 
        if raw_point[INDEX_POINT_TYPE] == TRAJECTORY_POINT_JOINT:
          movej(q, t=tmptime, r=0.0)
        elif raw_point[INDEX_POINT_TYPE] == TRAJECTORY_POINT_CARTESIAN:
          movel(p[q[0], q[1], q[2], q[3], q[4], q[5]], t=tmptime, r=0.0)
        elif raw_point[INDEX_POINT_TYPE] == TRAJECTORY_POINT_JOINT_SPLINE:
          # Cubic spline
          if raw_point[INDEX_SPLINE_TYPE] == CUBIC_SPLINES:
            cubicSplineRun(q, [0,0,0,0,0,0], tmptime)
          elif raw_point[INDEX_SPLINE_TYPE] == QUINTIC_SPLINES:
            quinticSplineRun(q, [0,0,0,0,0,0], [0,0,0,0,0,0], tmptime)
          end
        end
      end
    end
  end
  exit_critical
  socket_send_int(TRAJECTORY_RESULT_SUCCESS, "trajectory_socket")
  textmsg("Trajectory finished")
end

def clear_remaining_trajectory_points():
  while trajectory_points_left > 0:
    raw_point = socket_read_binary_integer(TRAJECTORY_DATA_DIMENSION+2, "trajectory_socket", get_steptime())
    trajectory_points_left = trajectory_points_left - 1
  end
end

# Helpers for speed control
def set_speedl(params_mult):
  cmd_twist = [params_mult[2], params_mult[3], params_mult[4], params_mult[5], params_mult[6], params_mult[7]] / MULT_jointstate
  control_mode = MODE_SPEEDL
end

thread speedlThread():
  textmsg("Starting speedl thread")
  while control_mode == MODE_SPEEDL:
    twist = cmd_twist
    speedl(twist, 40.0, steptime)
  end
  textmsg("speedl thread ended")
  stopj(STOPJ_ACCELERATION)
end

thread servoThreadP():
  textmsg("Starting pose servo thread")
  state = SERVO_IDLE
  while control_mode == MODE_POSE:
    enter_critical
    q = cmd_servo_q
    do_extrapolate = False
    if (cmd_servo_state == SERVO_IDLE):
      do_extrapolate = True
    end
    state = cmd_servo_state
    if cmd_servo_state > SERVO_UNINITIALIZED:
      cmd_servo_state = SERVO_IDLE
    end

    if do_extrapolate:
      extrapolate_count = extrapolate_count + 1
      if extrapolate_count > extrapolate_max_count:
        extrapolate_max_count = extrapolate_count
      end

      q = extrapolate()
      servoj(q, t=steptime, {{SERVO_J_REPLACE}})

    elif state == SERVO_RUNNING:
      extrapolate_count = 0
      servoj(q, t=steptime, {{SERVO_J_REPLACE}})
    else:
      extrapolate_count = 0
      sync()
    end
    exit_critical
  end
  textmsg("pose servo thread ended")
  stopj(STOPJ_ACCELERATION)
end

def set_servo_pose(params_mult):
  pose = p[params_mult[2], params_mult[3], params_mult[4], params_mult[5], params_mult[6], params_mult[7]] / MULT_jointstate
  cmd_servo_state = SERVO_RUNNING
  cmd_servo_q_last = cmd_servo_q
  cmd_servo_q = get_inverse_kin(pose, cmd_servo_q)
end

# Thread to receive script commands
thread script_commands():
  while control_mode > MODE_STOPPED:
    raw_command = socket_read_binary_integer(SCRIPT_COMMAND_DATA_DIMENSION, "script_command_socket", 0)
    if raw_command[0] > 0:
      command = raw_command[1]
      if command == ZERO_FTSENSOR:
        zero_ftsensor()
      elif command == SET_PAYLOAD:
        mass = raw_command[2] / MULT_jointstate
        cog = [raw_command[3], raw_command[4], raw_command[5]] / MULT_jointstate
        set_payload(mass, cog)
      elif command == SET_TOOL_VOLTAGE:
        tool_voltage = raw_command[2] / MULT_jointstate
        set_tool_voltage(tool_voltage)
      end
    end
  end
end


# HEADER_END

# NODE_CONTROL_LOOP_BEGINS

socket_open("{{SERVER_IP_REPLACE}}", {{SERVER_PORT_REPLACE}}, "reverse_socket")
socket_open("{{SERVER_IP_REPLACE}}", {{TRAJECTORY_SERVER_PORT_REPLACE}}, "trajectory_socket")
socket_open("{{SERVER_IP_REPLACE}}", {{SCRIPT_COMMAND_SERVER_PORT_REPLACE}}, "script_command_socket")

control_mode = MODE_UNINITIALIZED
thread_move = 0
thread_trajectory = 0
trajectory_points_left = 0
global keepalive = -2
# read_timeout = 0.02
# params_mult = socket_read_binary_integer(1+6+1, "reverse_socket", 0)
# textmsg("params2: ", params_mult)
textmsg("ExternalControl: External control active")
# keepalive = params_mult[1]
thread_script_commands = run script_commands()
read_timeout = 0.0
while (keepalive > 0 or keepalive == -2) and control_mode > MODE_STOPPED:
  enter_critical
  sync()
  params_mult = socket_read_binary_integer(1+6+1, "reverse_socket", read_timeout)
  # textmsg("params: ", params_mult)

  # first data packet received, set the timeout to 20ms
  read_timeout = 0.02
  
  if params_mult[0] > 0:
    keepalive = params_mult[1]

    # New control mode received
    if control_mode != params_mult[8]:
      # Stop the trajectory and flush the point in pipeline
      if control_mode == MODE_FORWARD:
        textmsg("kill thread_trajectory")
        kill thread_trajectory
        stopj(STOPJ_ACCELERATION)
        clear_remaining_trajectory_points()
      else:
        kill thread_move
        stopj(STOPJ_ACCELERATION)
      end

      # Run the new type of motion
      control_mode = params_mult[8]
      if control_mode == MODE_SERVOJ:
        thread_move = run servoThread()
      elif control_mode == MODE_SPEEDJ:
        thread_move = run speedThread()
      elif control_mode == MODE_FORWARD:
        textmsg("kill thread_move")
        kill thread_move
      elif control_mode == MODE_SPEEDL:
        thread_move = run speedlThread()
      elif control_mode == MODE_POSE:
        thread_move = run servoThreadP()
      end
    end

    # Update the motion commands with new parameters
    if control_mode == MODE_SERVOJ:
      set_servo_setpoint(params_mult)
    elif control_mode == MODE_SPEEDJ:
      set_speed(params_mult)
    elif control_mode == MODE_FORWARD:
      # textmsg("Update thread_trajectory")
      if params_mult[2] == TRAJECTORY_MODE_RECEIVE:
        textmsg("TRAJECTORY_MODE_RECEIVE")
        kill thread_trajectory
        clear_remaining_trajectory_points()
        trajectory_points_left = params_mult[3]
        thread_trajectory = run trajectoryThread()
      elif params_mult[2] == TRAJECTORY_MODE_CANCEL:
        textmsg("cancel received")
        kill thread_trajectory
        clear_remaining_trajectory_points()
        socket_send_int(TRAJECTORY_RESULT_CANCELED, "trajectory_socket")
      end
    elif control_mode == MODE_SPEEDL:
      set_speedl(params_mult)
    elif control_mode == MODE_POSE:
      set_servo_pose(params_mult)
    end
  else:
    keepalive = keepalive - 1
  end
  exit_critical
end

textmsg("ExternalControl: Stopping communication and control")
control_mode = MODE_STOPPED
join thread_move
join thread_trajectory
kill thread_script_commands
join thread_script_commands
textmsg("ExternalControl: All threads ended")
socket_close("reverse_socket")
socket_close("trajectory_socket")
socket_close("script_command_socket")

# NODE_CONTROL_LOOP_ENDS
