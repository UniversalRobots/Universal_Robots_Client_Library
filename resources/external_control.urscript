# HEADER_BEGIN

{{BEGIN_REPLACE}}

steptime = get_steptime()

textmsg("ExternalControl: steptime=", steptime)
MULT_jointstate = {{JOINT_STATE_REPLACE}}
MULT_time = {{TIME_REPLACE}}

STOPJ_ACCELERATION = 4.0

#Constants
SERVO_UNINITIALIZED = -1
SERVO_IDLE = 0
SERVO_RUNNING = 1

MODE_STOPPED = -2
MODE_UNINITIALIZED = -1
MODE_IDLE = 0
MODE_SERVOJ = 1
MODE_SPEEDJ = 2
MODE_FORWARD = 3
MODE_SPEEDL = 4
MODE_POSE = 5

TRAJECTORY_MODE_RECEIVE = 1
TRAJECTORY_MODE_CANCEL = -1

TRAJECTORY_POINT_JOINT = 0
TRAJECTORY_POINT_CARTESIAN = 1
TRAJECTORY_POINT_JOINT_SPLINE = 2
TRAJECTORY_DATA_DIMENSION = 3*6 + 1

TRAJECTORY_RESULT_SUCCESS = 0
TRAJECTORY_RESULT_CANCELED = 1
TRAJECTORY_RESULT_FAILURE = 2

ZERO_FTSENSOR = 0
SET_PAYLOAD = 1
SET_TOOL_VOLTAGE = 2
SCRIPT_COMMAND_DATA_DIMENSION = 5

#Global variables are also showed in the Teach pendants variable list
global cmd_servo_state = SERVO_UNINITIALIZED
global cmd_servo_qd = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
global cmd_servo_q = get_actual_joint_positions()
global cmd_servo_q_last = get_actual_joint_positions()
global cmd_twist = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
global extrapolate_count = 0
global extrapolate_max_count = 0
global control_mode = MODE_UNINITIALIZED
global trajectory_points_left = 0

def set_servo_setpoint(params_mult):
  cmd_servo_state = SERVO_RUNNING
  cmd_servo_q_last = cmd_servo_q
  cmd_servo_q = [params_mult[2] / MULT_jointstate, params_mult[3] / MULT_jointstate, params_mult[4] / MULT_jointstate, params_mult[5] / MULT_jointstate, params_mult[6] / MULT_jointstate, params_mult[7] / MULT_jointstate]
end

def extrapolate():
  diff = [cmd_servo_q[0] - cmd_servo_q_last[0], cmd_servo_q[1] - cmd_servo_q_last[1], cmd_servo_q[2] - cmd_servo_q_last[2], cmd_servo_q[3] - cmd_servo_q_last[3], cmd_servo_q[4] - cmd_servo_q_last[4], cmd_servo_q[5] - cmd_servo_q_last[5]]
  cmd_servo_q_last = cmd_servo_q
  cmd_servo_q = [cmd_servo_q[0] + diff[0], cmd_servo_q[1] + diff[1], cmd_servo_q[2] + diff[2], cmd_servo_q[3] + diff[3], cmd_servo_q[4] + diff[4], cmd_servo_q[5] + diff[5]]

  return cmd_servo_q
end

thread servoThread():
  textmsg("ExternalControl: Starting servo thread")
  state = SERVO_IDLE
  while control_mode == MODE_SERVOJ:
    enter_critical
    q = cmd_servo_q
    do_extrapolate = False
    if (cmd_servo_state == SERVO_IDLE):
      do_extrapolate = True
    end
    state = cmd_servo_state
    if cmd_servo_state > SERVO_UNINITIALIZED:
      cmd_servo_state = SERVO_IDLE
    end

    if do_extrapolate:
      extrapolate_count = extrapolate_count + 1
      if extrapolate_count > extrapolate_max_count:
        extrapolate_max_count = extrapolate_count
      end

      q = extrapolate()
      servoj(q, t=steptime, {{SERVO_J_REPLACE}})

    elif state == SERVO_RUNNING:
      extrapolate_count = 0
      servoj(q, t=steptime, {{SERVO_J_REPLACE}})
    else:
      extrapolate_count = 0
      sync()
    end
    exit_critical
  end
  textmsg("ExternalControl: servo thread ended")
  stopj(STOPJ_ACCELERATION)
end

# Helpers for speed control
def set_speed(params_mult):
  cmd_servo_qd = [params_mult[2] / MULT_jointstate, params_mult[3] / MULT_jointstate, params_mult[4] / MULT_jointstate, params_mult[5] / MULT_jointstate, params_mult[6] / MULT_jointstate, params_mult[7] / MULT_jointstate]
  control_mode = MODE_SPEEDJ
end

thread speedThread():
  textmsg("ExternalControl: Starting speed thread")
  while control_mode == MODE_SPEEDJ:
    qd = cmd_servo_qd
    speedj(qd, 40.0, steptime)
  end
  textmsg("ExternalControl: speedj thread ended")
  stopj(STOPJ_ACCELERATION)
end

#Calculate Cubic Spline coefficients
# coefficients = [[0.0, 0.0, 0.0, 0.0, 0.0, 0.0],[0.0, 0.0, 0.0, 0.0, 0.0, 0.0],[0.0, 0.0, 0.0, 0.0, 0.0, 0.0],[0.0, 0.0, 0.0, 0.0, 0.0, 0.0],[0.0, 0.0, 0.0, 0.0, 0.0, 0.0],[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]]
coefficients0 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
coefficients1 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
coefficients2 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
coefficients3 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
coefficients4 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
coefficients5 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
splineTimer = 0.0
splineTravelTime = 0.0

def reset_spline_coeff():
  # coefficients = [[0.0, 0.0, 0.0, 0.0, 0.0, 0.0],[0.0, 0.0, 0.0, 0.0, 0.0, 0.0],[0.0, 0.0, 0.0, 0.0, 0.0, 0.0],[0.0, 0.0, 0.0, 0.0, 0.0, 0.0],[0.0, 0.0, 0.0, 0.0, 0.0, 0.0],[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]]
  coefficients0 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  coefficients1 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  coefficients2 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  coefficients3 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  coefficients4 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  coefficients5 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  splineTimer = 0.0
  splineTravelTime = 0.0
end

def cubicSplineCal(q_target, qd_target, time):
  q = get_target_joint_positions()
  qd = get_target_joint_speeds()

  coefficients0 = q
  coefficients1 = qd
  coefficients2 = (-3 * q + q_target * 3- qd * 2 * time - qd_target * time) / pow(time,2)
  coefficients3 = (2 * q - 2 * q_target+ qd * time + qd_target * time) / pow(time,3)
  splineTimer = 0.0
  splineTravelTime  = time
end

#Spline polynomial and move function
def cubicSplineRun():      
  splineTimer = splineTimer + get_steptime()
  t1 = splineTimer
  t2 = t1 * t1
  t3 = t2 * t1

  #q = coefficients0 + t1*coefficients1  + t2*coefficients2  +  t3*coefficients3
  qd = coefficients1 + 2*t1*coefficients2 + 3*t2*coefficients3

  speedj(qd,1,get_steptime())

  # Return True as long it is running the spline
  return (splineTimer < (splineTravelTime + get_steptime()))
end

qdd_last = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
def quinticSplineCal(q_target, qd_target, qdd_target, time):
  q = get_target_joint_positions()
  qd = get_target_joint_speeds()
  qdd = qdd_last
  TIME1 =  time
  TIME2 = pow(time,2)
  TIME3 = pow(time,3)
  TIME4 = pow(time,4)
  TIME5 = pow(time,5)

  # M = [[-6/TIME5, -3/TIME4, -0.5/TIME3, 6/TIME5, -3/TIME4, 0.5/TIME3], [15/TIME4, 8/TIME3, 1.5/TIME2, -15/TIME4, 7/TIME3, -1/TIME2], [-10/TIME3, -6/TIME2, -1.5/TIME, 10/TIME3, -4/TIME2, 0.5/TIME], [0, 0, 0.5, 0, 0, 0], [0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0]]
  # coefficients = M * [q, q_target, qd, qd_target, qdd, qdd_target]

  coefficients0 = q
  coefficients1 = qd
  coefficients2 = 0.5*qdd
  coefficients3 = (-20.0 * q + 20.0 * q_target - 3.0 * qdd * TIME2 + qdd_target * TIME2 - 12.0 * qd * time - 8.0 * qd_target * time) / (2.0 * TIME3)
  coefficients4 = (30.0 * q - 30.0 * q_target + 3.0* qdd * TIME2 - 2.0 * qdd_target * TIME2 + 16.0 * qd * time + 14.0 * qd_target * time) / (2.0 * TIME4)
  coefficients5 = (-12.0 * q + 12.0 * q_target - qdd * TIME2 + qdd_target * TIME2 - 6.0 * qd * time - 6.0 * qd_target * time) / (2.0 * TIME5)
  splineTimer = 0.0
  splineTravelTime  = time
end

def quinticSplineRun():
  splineTimer = splineTimer + get_steptime()
  TIME1 = splineTimer
  TIME2  = pow(TIME1,2)
  TIME3  = pow(TIME1,3)
  TIME4  = pow(TIME1,4)
  TIME5  = pow(TIME1,5)

  #q = coefficients0 + coefficients1 + TIME2*coefficients2 + TIME3*coefficients3 + TIME4*coefficients4 + TIME5*coefficients5
  qd = coefficients1 + 2.0*coefficients2 + 3.0*TIME2*coefficients3 + 4.0*TIME3*coefficients4 + 5.0*TIME4*coefficients5
  qdd_last = 2.0*coefficients2 + 6.0*coefficients3 + 12.0*TIME2*coefficients4 + 20.0*TIME3*coefficients5

  speedj(qd,1,get_steptime())

  # Return True as long it is running the spline
  return (splineTimer < (splineTravelTime + get_steptime()))
end

thread jointTrajectoryThread():
  textmsg("Executing trajectory. Number of points: ", trajectory_points_left)
  local INDEX_TIME = TRAJECTORY_DATA_DIMENSION
  local INDEX_BLEND = INDEX_TIME + 1
  local INDEX_POINT_TYPE = INDEX_BLEND + 1
  reset_spline_coeff()
  while trajectory_points_left > 0:
    enter_critical
    #reading trajectory point + blend radius + type of point (cartesian/joint based)
    raw_point = socket_read_binary_integer(TRAJECTORY_DATA_DIMENSION+1+1, "trajectory_socket")
    trajectory_points_left = trajectory_points_left - 1
    exit_critical
    textmsg("raw point", raw_point)
    if raw_point[0] > 0:
      q = [ raw_point[1] / MULT_jointstate, raw_point[2] / MULT_jointstate, raw_point[3] / MULT_jointstate, raw_point[4] / MULT_jointstate, raw_point[5] / MULT_jointstate, raw_point[6] / MULT_jointstate]
      tmptime = raw_point[INDEX_TIME] / MULT_time
      blend_radius = raw_point[INDEX_BLEND] / MULT_time

      if trajectory_points_left > 0:
        if raw_point[INDEX_POINT_TYPE] == TRAJECTORY_POINT_JOINT:
          textmsg("Executing movej with blending")
          movej(q, t=tmptime, r=blend_radius)
        elif raw_point[INDEX_POINT_TYPE] == TRAJECTORY_POINT_CARTESIAN:
          textmsg("Executing movel with blending")
          movel(p[q[0], q[1], q[2], q[3], q[4], q[5]], t=tmptime, r=blend_radius)
        elif raw_point[INDEX_POINT_TYPE] == TRAJECTORY_POINT_JOINT_SPLINE:
          textmsg("Executing splind with blending")
          qd = [ raw_point[7] / MULT_jointstate, raw_point[8] / MULT_jointstate, raw_point[9] / MULT_jointstate, raw_point[10] / MULT_jointstate, raw_point[11] / MULT_jointstate, raw_point[12] / MULT_jointstate]
          qdd = [ raw_point[13] / MULT_jointstate, raw_point[14] / MULT_jointstate, raw_point[15] / MULT_jointstate, raw_point[16] / MULT_jointstate, raw_point[17] / MULT_jointstate, raw_point[18] / MULT_jointstate]
          #cubicSplineCal(q, qd, tmptime)
          quinticSplineCal(q, qd, qdd, tmptime)

          running_spline = True
          while running_spline:
            #running_spline = cubicSplineRun()
            running_spline = quinticSplineRun()
          end
        end
      else:
        if raw_point[INDEX_POINT_TYPE] == TRAJECTORY_POINT_JOINT:
          # textmsg("Executing movej without blending")
          movej(q, t=tmptime, r=0.0)
        elif raw_point[INDEX_POINT_TYPE] == TRAJECTORY_POINT_CARTESIAN:
          # textmsg("Executing movel without blending")
          movel(p[q[0], q[1], q[2], q[3], q[4], q[5]], t=tmptime, r=0.0)
        elif raw_point[INDEX_POINT_TYPE] == TRAJECTORY_POINT_JOINT_SPLINE: 
          cubicSplineCal(q, [0,0,0,0,0,0], tmptime)
          running_spline = True
          while running_spline:
            #running_spline = cubicSplineRun()
            running_spline = quinticSplineRun()
          end
        end
      end
    end
  end
  socket_send_int(TRAJECTORY_RESULT_SUCCESS, "trajectory_socket")
  textmsg("Trajectory finished")
end

def clear_remaining_trajectory_points():
  while trajectory_points_left > 0:
    raw_point = socket_read_binary_integer(TRAJECTORY_DATA_DIMENSION+2, "trajectory_socket")
    trajectory_points_left = trajectory_points_left - 1
  end
end

# Helpers for speed control
def set_speedl(params_mult):
  cmd_twist = [params_mult[2] / MULT_jointstate, params_mult[3] / MULT_jointstate, params_mult[4] / MULT_jointstate, params_mult[5] / MULT_jointstate, params_mult[6] / MULT_jointstate, params_mult[7] / MULT_jointstate]
  control_mode = MODE_SPEEDL
end

thread speedlThread():
  textmsg("Starting speedl thread")
  while control_mode == MODE_SPEEDL:
    twist = cmd_twist
    speedl(twist, 40.0, steptime)
  end
  textmsg("speedl thread ended")
  stopj(STOPJ_ACCELERATION)
end

thread servoThreadP():
  textmsg("Starting pose servo thread")
  state = SERVO_IDLE
  while control_mode == MODE_POSE:
    enter_critical
    q = cmd_servo_q
    do_extrapolate = False
    if (cmd_servo_state == SERVO_IDLE):
      do_extrapolate = True
    end
    state = cmd_servo_state
    if cmd_servo_state > SERVO_UNINITIALIZED:
      cmd_servo_state = SERVO_IDLE
    end

    if do_extrapolate:
      extrapolate_count = extrapolate_count + 1
      if extrapolate_count > extrapolate_max_count:
        extrapolate_max_count = extrapolate_count
      end

      q = extrapolate()
      servoj(q, t=steptime, {{SERVO_J_REPLACE}})

    elif state == SERVO_RUNNING:
      extrapolate_count = 0
      servoj(q, t=steptime, {{SERVO_J_REPLACE}})
    else:
      extrapolate_count = 0
      sync()
    end
    exit_critical
  end
  textmsg("pose servo thread ended")
  stopj(STOPJ_ACCELERATION)
end

def set_servo_pose(params_mult):
  pose = p[params_mult[2] / MULT_jointstate, params_mult[3] / MULT_jointstate, params_mult[4] / MULT_jointstate, params_mult[5] / MULT_jointstate, params_mult[6] / MULT_jointstate, params_mult[7] / MULT_jointstate]
  cmd_servo_state = SERVO_RUNNING
  cmd_servo_q_last = cmd_servo_q
  cmd_servo_q = get_inverse_kin(pose, cmd_servo_q)
end

# Thread to receive script commands
thread script_commands():
  while control_mode > MODE_STOPPED:
    raw_command = socket_read_binary_integer(SCRIPT_COMMAND_DATA_DIMENSION, "script_command_socket", 0)
    if raw_command[0] > 0:
      command = raw_command[1]
      if command == ZERO_FTSENSOR:
        zero_ftsensor()
      elif command == SET_PAYLOAD:
        mass = raw_command[2] / MULT_jointstate
        cog = [raw_command[3] / MULT_jointstate, raw_command[4] / MULT_jointstate, raw_command[5] / MULT_jointstate]
        set_payload(mass, cog)
      elif command == SET_TOOL_VOLTAGE:
        tool_voltage = raw_command[2] / MULT_jointstate
        set_tool_voltage(tool_voltage)
      end
    end
  end
end


# HEADER_END

# NODE_CONTROL_LOOP_BEGINS

socket_open("{{SERVER_IP_REPLACE}}", {{SERVER_PORT_REPLACE}}, "reverse_socket")
socket_open("{{SERVER_IP_REPLACE}}", {{TRAJECTORY_SERVER_PORT_REPLACE}}, "trajectory_socket")
socket_open("{{SERVER_IP_REPLACE}}", {{SCRIPT_COMMAND_SERVER_PORT_REPLACE}}, "script_command_socket")

control_mode = MODE_UNINITIALIZED
thread_move = 0
thread_trajectory = 0
trajectory_points_left = 0
global keepalive = -2
params_mult = socket_read_binary_integer(1+6+1, "reverse_socket", 0)
textmsg("ExternalControl: External control active")
keepalive = params_mult[1]
thread_script_commands = run script_commands()
while keepalive > 0 and control_mode > MODE_STOPPED:
  enter_critical
  params_mult = socket_read_binary_integer(1+6+1, "reverse_socket", 0.02) # steptime could work as well, but does not work in simulation
  if params_mult[0] > 0:
    keepalive = params_mult[1]

    # New control mode received
    if control_mode != params_mult[8]:
      #Stop the trajectory and flush the point in pipeline
      if control_mode == MODE_FORWARD:
        kill thread_trajectory
        stopj(STOPJ_ACCELERATION)
        clear_remaining_trajectory_points()
      end

      # Stop the movement currently running
      textmsg("terminating all ongoing motion")
      kill thread_move
      stopj(STOPJ_ACCELERATION)

      #Run the new type of motion
      control_mode = params_mult[8]
      textmsg("robot is standing still")
      if control_mode == MODE_SERVOJ:
        thread_move = run servoThread()
      elif control_mode == MODE_SPEEDJ:
        thread_move = run speedThread()
      elif control_mode == MODE_FORWARD:
        kill thread_move
      elif control_mode == MODE_SPEEDL:
        thread_move = run speedlThread()
      elif control_mode == MODE_POSE:
        thread_move = run servoThreadP()
      end
    end

    # Update the motion commands with new parameters
    if control_mode == MODE_SERVOJ:
      set_servo_setpoint(params_mult)
    elif control_mode == MODE_SPEEDJ:
      set_speed(params_mult)
    elif control_mode == MODE_FORWARD:
      if params_mult[2] == TRAJECTORY_MODE_RECEIVE:
        kill thread_trajectory
        clear_remaining_trajectory_points()
        trajectory_points_left = params_mult[3]
        thread_trajectory = run jointTrajectoryThread()
      elif params_mult[2] == TRAJECTORY_MODE_CANCEL:
        textmsg("cancel received")
        kill thread_trajectory
        clear_remaining_trajectory_points()
        socket_send_int(TRAJECTORY_RESULT_CANCELED, "trajectory_socket")
      end
    elif control_mode == MODE_SPEEDL:
      set_speedl(params_mult)
    elif control_mode == MODE_POSE:
      set_servo_pose(params_mult)
    end
  else:
    keepalive = keepalive - 1
  end
  exit_critical
end

textmsg("ExternalControl: Stopping communication and control")
control_mode = MODE_STOPPED
join thread_move
join thread_trajectory
kill thread_script_commands
join thread_script_commands
textmsg("ExternalControl: All threads ended")
socket_close("reverse_socket")
socket_close("trajectory_socket")
socket_close("script_command_socket")

# NODE_CONTROL_LOOP_ENDS
