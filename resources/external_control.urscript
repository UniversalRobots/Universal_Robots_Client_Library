# HEADER_BEGIN

{{BEGIN_REPLACE}}

steptime = get_steptime()

textmsg("ExternalControl: steptime=", steptime)
MULT_jointstate = {{JOINT_STATE_REPLACE}}
MULT_time = {{TIME_REPLACE}}

STOPJ_ACCELERATION = 4.0

#Constants
SERVO_UNINITIALIZED = -1
SERVO_IDLE = 0
SERVO_RUNNING = 1

MODE_STOPPED = -2
MODE_UNINITIALIZED = -1
MODE_IDLE = 0
MODE_SERVOJ = 1
MODE_SPEEDJ = 2
MODE_FORWARD = 3
MODE_SPEEDL = 4
MODE_POSE = 5
MODE_SPLINE = 6

TRAJECTORY_MODE_RECEIVE = 1
TRAJECTORY_MODE_CANCEL = -1

TRAJECTORY_POINT_INTERPOLATION = 0
TRAJECTORY_SPLINE_INTERPOLATION = 1

TRAJECTORY_POINT_JOINT = 0
TRAJECTORY_POINT_CARTESIAN = 1
TRAJECTORY_POINT_JOINT_SPLINE = 2
TRAJECTORY_DATA_DIMENSION = 3*6 + 1

TRAJECTORY_RESULT_SUCCESS = 0
TRAJECTORY_RESULT_CANCELED = 1
TRAJECTORY_RESULT_FAILURE = 2

ZERO_FTSENSOR = 0
SET_PAYLOAD = 1
SET_TOOL_VOLTAGE = 2
SCRIPT_COMMAND_DATA_DIMENSION = 5

CUBIC_SPLINES = 0
QUINTIC_SPLINES = 1

#Global variables are also showed in the Teach pendants variable list
global cmd_servo_state = SERVO_UNINITIALIZED
global cmd_servo_qd = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
global cmd_servo_q = get_actual_joint_positions()
global cmd_servo_q_last = get_actual_joint_positions()
global cmd_twist = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
global extrapolate_count = 0
global extrapolate_max_count = 0
global control_mode = MODE_UNINITIALIZED
global trajectory_points_left = 0

def set_servo_setpoint(params_mult):
  cmd_servo_state = SERVO_RUNNING
  cmd_servo_q_last = cmd_servo_q
  cmd_servo_q = [params_mult[2] / MULT_jointstate, params_mult[3] / MULT_jointstate, params_mult[4] / MULT_jointstate, params_mult[5] / MULT_jointstate, params_mult[6] / MULT_jointstate, params_mult[7] / MULT_jointstate]
end

def extrapolate():
  diff = [cmd_servo_q[0] - cmd_servo_q_last[0], cmd_servo_q[1] - cmd_servo_q_last[1], cmd_servo_q[2] - cmd_servo_q_last[2], cmd_servo_q[3] - cmd_servo_q_last[3], cmd_servo_q[4] - cmd_servo_q_last[4], cmd_servo_q[5] - cmd_servo_q_last[5]]
  cmd_servo_q_last = cmd_servo_q
  cmd_servo_q = [cmd_servo_q[0] + diff[0], cmd_servo_q[1] + diff[1], cmd_servo_q[2] + diff[2], cmd_servo_q[3] + diff[3], cmd_servo_q[4] + diff[4], cmd_servo_q[5] + diff[5]]

  return cmd_servo_q
end

thread servoThread():
  textmsg("ExternalControl: Starting servo thread")
  state = SERVO_IDLE
  while control_mode == MODE_SERVOJ:
    enter_critical
    q = cmd_servo_q
    do_extrapolate = False
    if (cmd_servo_state == SERVO_IDLE):
      do_extrapolate = True
    end
    state = cmd_servo_state
    if cmd_servo_state > SERVO_UNINITIALIZED:
      cmd_servo_state = SERVO_IDLE
    end

    if do_extrapolate:
      extrapolate_count = extrapolate_count + 1
      if extrapolate_count > extrapolate_max_count:
        extrapolate_max_count = extrapolate_count
      end

      q = extrapolate()
      servoj(q, t=steptime, {{SERVO_J_REPLACE}})

    elif state == SERVO_RUNNING:
      extrapolate_count = 0
      servoj(q, t=steptime, {{SERVO_J_REPLACE}})
    else:
      extrapolate_count = 0
      sync()
    end
    exit_critical
  end
  textmsg("ExternalControl: servo thread ended")
  stopj(STOPJ_ACCELERATION)
end

# Helpers for speed control
def set_speed(params_mult):
  cmd_servo_qd = [params_mult[2] / MULT_jointstate, params_mult[3] / MULT_jointstate, params_mult[4] / MULT_jointstate, params_mult[5] / MULT_jointstate, params_mult[6] / MULT_jointstate, params_mult[7] / MULT_jointstate]
  control_mode = MODE_SPEEDJ
end

thread speedThread():
  textmsg("ExternalControl: Starting speed thread")
  while control_mode == MODE_SPEEDJ:
    qd = cmd_servo_qd
    speedj(qd, 40.0, steptime)
  end
  textmsg("ExternalControl: speedj thread ended")
  stopj(STOPJ_ACCELERATION)
end

def cubicSplineRun(start_q, end_q, start_qd, end_qd, time):
  # Coefficients0 is not included, since we control velocity and it is therefore not needed
  coefficients1 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  coefficients2 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  coefficients3 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  coefficients4 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  coefficients5 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]

  if time == 0.0:
    coefficients1 = start_qd
  else:
    coefficients1 = start_qd
    coefficients2 = (-3 * start_q + end_q * 3 - start_qd * 2 * time - end_qd * time) / pow(time,2)
    coefficients3 = (2 * start_q - 2 * end_q + start_qd * time + end_qd * time) / pow(time,3)
  end
  splineTimer = 0.0
  splineTravelTime = time
  jointSplineRun(coefficients1, coefficients2, coefficients3, coefficients4, coefficients5, splineTimer, splineTravelTime)
end

def quinticSplineRun(start_q, end_q, start_qd, end_qd, start_qdd, end_qdd, time):
  # Coefficients0 is not included, since we control velocity and it is therefore not needed
  coefficients1 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  coefficients2 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  coefficients3 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  coefficients4 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  coefficients5 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]

  TIME2 = pow(time,2)
  TIME3 = pow(time,3)
  TIME4 = pow(time,4)
  TIME5 = pow(time,5)

  if time == 0.0:
    coefficients1 = start_qd
    coefficients2 = 0.5*start_qdd
    coefficients3 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    coefficients4 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    coefficients5 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0] 
  else:
    coefficients1 = start_qd
    coefficients2 = 0.5*start_qdd
    coefficients3 = (-20.0 * start_q + 20.0 * end_q - 3.0 * start_qdd * TIME2 + end_qdd * TIME2 - 12.0 * start_qd * time - 8.0 * end_qd * time) / (2.0 * TIME3)
    coefficients4 = (30.0 * start_q - 30.0 * end_q + 3.0* start_qdd * TIME2 - 2.0 * end_qdd * TIME2 + 16.0 * start_qd * time + 14.0 * end_qd * time) / (2.0 * TIME4)
    coefficients5 = (-12.0 * start_q + 12.0 * end_q - start_qdd * TIME2 + end_qdd * TIME2 - 6.0 * start_qd * time - 6.0 * end_qd * time) / (2.0 * TIME5)
  end
  splineTimer = 0.0
  splineTravelTime  = time
  jointSplineRun(coefficients1, coefficients2, coefficients3, coefficients4, coefficients5, splineTimer, splineTravelTime)
end

def jointSplineRun(coefficients1, coefficients2, coefficients3, coefficients4, coefficients5, splineTimer, splineTravelTime):
  spline_step_time = get_steptime()
  if splineTravelTime < spline_step_time:
    TIME1 = splineTimer
    TIME2  = pow(TIME1,2)
    TIME3  = pow(TIME1,3)
    TIME4  = pow(TIME1,4)

    qd = coefficients1 + 2.0*TIME1*coefficients2 + 3.0*TIME2*coefficients3 + 4.0*TIME3*coefficients4 + 5.0*TIME4*coefficients5
    speedj(qd,1000,spline_step_time)
  end

  splineTimer = splineTimer + spline_step_time
  while splineTimer <= splineTravelTime:
    TIME1 = splineTimer
    TIME2  = pow(TIME1,2)
    TIME3  = pow(TIME1,3)
    TIME4  = pow(TIME1,4)

    qd = coefficients1 + 2.0*TIME1*coefficients2 + 3.0*TIME2*coefficients3 + 4.0*TIME3*coefficients4 + 5.0*TIME4*coefficients5
    speedj(qd,1000,spline_step_time)
    splineTimer = splineTimer + spline_step_time
  end
end

thread trajectoryThread():
  textmsg("Executing trajectory. Number of points: ", trajectory_points_left)
  local INDEX_TIME = TRAJECTORY_DATA_DIMENSION
  local INDEX_BLEND = INDEX_TIME + 1
  # same index as blend parameter, depending on point type
  local INDEX_SPLINE_TYPE = INDEX_BLEND 
  local INDEX_POINT_TYPE = INDEX_BLEND + 1
  old_qdd = [0, 0, 0, 0, 0, 0]
  while trajectory_points_left > 0:
    enter_critical
    #reading trajectory point + blend radius + type of point (cartesian/joint based)
    raw_point = socket_read_binary_integer(TRAJECTORY_DATA_DIMENSION+1+1, "trajectory_socket")
    trajectory_points_left = trajectory_points_left - 1
    exit_critical
    if raw_point[0] > 0:
      q = [ raw_point[1] / MULT_jointstate, raw_point[2] / MULT_jointstate, raw_point[3] / MULT_jointstate, raw_point[4] / MULT_jointstate, raw_point[5] / MULT_jointstate, raw_point[6] / MULT_jointstate]
      tmptime = raw_point[INDEX_TIME] / MULT_time
      blend_radius = raw_point[INDEX_BLEND] / MULT_time
      if trajectory_points_left > 0:
        # MoveJ point
        if raw_point[INDEX_POINT_TYPE] == TRAJECTORY_POINT_JOINT:
          movej(q, t=tmptime, r=blend_radius)
          # reset old acceleration
          old_qdd = [0, 0, 0, 0, 0, 0]
        # Movel point
        elif raw_point[INDEX_POINT_TYPE] == TRAJECTORY_POINT_CARTESIAN:
          movel(p[q[0], q[1], q[2], q[3], q[4], q[5]], t=tmptime, r=blend_radius)
          old_qdd = [0, 0, 0, 0, 0, 0] # reset old acceleration
        # Joint spline point
        elif raw_point[INDEX_POINT_TYPE] == TRAJECTORY_POINT_JOINT_SPLINE:
          tmptime = raw_point[INDEX_TIME] / MULT_time
          # Cubic spline
          if raw_point[INDEX_SPLINE_TYPE] == CUBIC_SPLINES:
            qd = [ raw_point[7] / MULT_jointstate, raw_point[8] / MULT_jointstate, raw_point[9] / MULT_jointstate, raw_point[10] / MULT_jointstate, raw_point[11] / MULT_jointstate, raw_point[12] / MULT_jointstate]
            cubicSplineRun(get_target_joint_positions(), q, get_target_joint_speeds(), qd, tmptime)
             # reset old acceleration
            old_qdd = [0, 0, 0, 0, 0, 0]
          # Quintic spline
          elif raw_point[INDEX_SPLINE_TYPE] == QUINTIC_SPLINES:
            qd = [ raw_point[7] / MULT_jointstate, raw_point[8] / MULT_jointstate, raw_point[9] / MULT_jointstate, raw_point[10] / MULT_jointstate, raw_point[11] / MULT_jointstate, raw_point[12] / MULT_jointstate]
            qdd = [ raw_point[13] / MULT_jointstate, raw_point[14] / MULT_jointstate, raw_point[15] / MULT_jointstate, raw_point[16] / MULT_jointstate, raw_point[17] / MULT_jointstate, raw_point[18] / MULT_jointstate]
            quinticSplineRun(get_target_joint_positions(),q, get_target_joint_speeds(), qd, old_qdd, qdd, tmptime)
            old_qdd = qdd
          end        
        end
      # Last trajectory point
      else: 
        if raw_point[INDEX_POINT_TYPE] == TRAJECTORY_POINT_JOINT:
          movej(q, t=tmptime, r=0.0)
        elif raw_point[INDEX_POINT_TYPE] == TRAJECTORY_POINT_CARTESIAN:
          movel(p[q[0], q[1], q[2], q[3], q[4], q[5]], t=tmptime, r=0.0)
        elif raw_point[INDEX_POINT_TYPE] == TRAJECTORY_POINT_JOINT_SPLINE:
          cubicSplineRun(get_target_joint_positions(), q, get_target_joint_speeds(), [0,0,0,0,0,0], tmptime)
        end
      end
    end
  end
  socket_send_int(TRAJECTORY_RESULT_SUCCESS, "trajectory_socket")
  textmsg("Trajectory finished")
end

def clear_remaining_trajectory_points():
  while trajectory_points_left > 0:
    raw_point = socket_read_binary_integer(TRAJECTORY_DATA_DIMENSION+2, "trajectory_socket")
    trajectory_points_left = trajectory_points_left - 1
  end
end

# Helpers for speed control
def set_speedl(params_mult):
  cmd_twist = [params_mult[2] / MULT_jointstate, params_mult[3] / MULT_jointstate, params_mult[4] / MULT_jointstate, params_mult[5] / MULT_jointstate, params_mult[6] / MULT_jointstate, params_mult[7] / MULT_jointstate]
  control_mode = MODE_SPEEDL
end

thread speedlThread():
  textmsg("Starting speedl thread")
  while control_mode == MODE_SPEEDL:
    twist = cmd_twist
    speedl(twist, 40.0, steptime)
  end
  textmsg("speedl thread ended")
  stopj(STOPJ_ACCELERATION)
end

thread servoThreadP():
  textmsg("Starting pose servo thread")
  state = SERVO_IDLE
  while control_mode == MODE_POSE:
    enter_critical
    q = cmd_servo_q
    do_extrapolate = False
    if (cmd_servo_state == SERVO_IDLE):
      do_extrapolate = True
    end
    state = cmd_servo_state
    if cmd_servo_state > SERVO_UNINITIALIZED:
      cmd_servo_state = SERVO_IDLE
    end

    if do_extrapolate:
      extrapolate_count = extrapolate_count + 1
      if extrapolate_count > extrapolate_max_count:
        extrapolate_max_count = extrapolate_count
      end

      q = extrapolate()
      servoj(q, t=steptime, {{SERVO_J_REPLACE}})

    elif state == SERVO_RUNNING:
      extrapolate_count = 0
      servoj(q, t=steptime, {{SERVO_J_REPLACE}})
    else:
      extrapolate_count = 0
      sync()
    end
    exit_critical
  end
  textmsg("pose servo thread ended")
  stopj(STOPJ_ACCELERATION)
end

def set_servo_pose(params_mult):
  pose = p[params_mult[2] / MULT_jointstate, params_mult[3] / MULT_jointstate, params_mult[4] / MULT_jointstate, params_mult[5] / MULT_jointstate, params_mult[6] / MULT_jointstate, params_mult[7] / MULT_jointstate]
  cmd_servo_state = SERVO_RUNNING
  cmd_servo_q_last = cmd_servo_q
  cmd_servo_q = get_inverse_kin(pose, cmd_servo_q)
end

# Thread to receive script commands
thread script_commands():
  while control_mode > MODE_STOPPED:
    raw_command = socket_read_binary_integer(SCRIPT_COMMAND_DATA_DIMENSION, "script_command_socket", 0)
    if raw_command[0] > 0:
      command = raw_command[1]
      if command == ZERO_FTSENSOR:
        zero_ftsensor()
      elif command == SET_PAYLOAD:
        mass = raw_command[2] / MULT_jointstate
        cog = [raw_command[3] / MULT_jointstate, raw_command[4] / MULT_jointstate, raw_command[5] / MULT_jointstate]
        set_payload(mass, cog)
      elif command == SET_TOOL_VOLTAGE:
        tool_voltage = raw_command[2] / MULT_jointstate
        set_tool_voltage(tool_voltage)
      end
    end
  end
end


# HEADER_END

# NODE_CONTROL_LOOP_BEGINS

socket_open("{{SERVER_IP_REPLACE}}", {{SERVER_PORT_REPLACE}}, "reverse_socket")
socket_open("{{SERVER_IP_REPLACE}}", {{TRAJECTORY_SERVER_PORT_REPLACE}}, "trajectory_socket")
socket_open("{{SERVER_IP_REPLACE}}", {{SCRIPT_COMMAND_SERVER_PORT_REPLACE}}, "script_command_socket")

control_mode = MODE_UNINITIALIZED
thread_move = 0
thread_trajectory = 0
trajectory_points_left = 0
global keepalive = -2
read_timeout = 0.02
params_mult = socket_read_binary_integer(1+6+1, "reverse_socket", 0)
textmsg("ExternalControl: External control active")
keepalive = params_mult[1]
thread_script_commands = run script_commands()
while keepalive > 0 and control_mode > MODE_STOPPED:
  enter_critical
  params_mult = socket_read_binary_integer(1+6+1, "reverse_socket", read_timeout)
  if params_mult[0] > 0:
    keepalive = params_mult[1]

    # New control mode received
    if control_mode != params_mult[8]:
      # Stop the trajectory and flush the point in pipeline
      if control_mode == MODE_FORWARD:
        kill thread_trajectory
        stopj(STOPJ_ACCELERATION)
        clear_remaining_trajectory_points()
      else:
        kill thread_move
        stopj(STOPJ_ACCELERATION)
      end

      # Run the new type of motion
      control_mode = params_mult[8]
      if control_mode == MODE_SERVOJ:
        thread_move = run servoThread()
      elif control_mode == MODE_SPEEDJ:
        thread_move = run speedThread()
      elif control_mode == MODE_FORWARD:
        kill thread_move
      elif control_mode == MODE_SPEEDL:
        thread_move = run speedlThread()
      elif control_mode == MODE_POSE:
        thread_move = run servoThreadP()
      end
    end

    # Update the motion commands with new parameters
    if control_mode == MODE_SERVOJ:
      set_servo_setpoint(params_mult)
    elif control_mode == MODE_SPEEDJ:
      set_speed(params_mult)
    elif control_mode == MODE_FORWARD:
      if params_mult[2] == TRAJECTORY_MODE_RECEIVE:
        kill thread_trajectory
        clear_remaining_trajectory_points()
        trajectory_points_left = params_mult[3]
        thread_trajectory = run trajectoryThread()
      elif params_mult[2] == TRAJECTORY_MODE_CANCEL:
        textmsg("cancel received")
        kill thread_trajectory
        clear_remaining_trajectory_points()
        socket_send_int(TRAJECTORY_RESULT_CANCELED, "trajectory_socket")
      end
    elif control_mode == MODE_SPEEDL:
      set_speedl(params_mult)
    elif control_mode == MODE_POSE:
      set_servo_pose(params_mult)
    end
  else:
    keepalive = keepalive - 1
  end
  exit_critical
end

textmsg("ExternalControl: Stopping communication and control")
control_mode = MODE_STOPPED
join thread_move
join thread_trajectory
kill thread_script_commands
join thread_script_commands
textmsg("ExternalControl: All threads ended")
socket_close("reverse_socket")
socket_close("trajectory_socket")
socket_close("script_command_socket")

# NODE_CONTROL_LOOP_ENDS
