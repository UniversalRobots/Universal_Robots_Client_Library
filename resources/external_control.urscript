# HEADER_BEGIN

{{BEGIN_REPLACE}}

steptime = get_steptime()

textmsg("ExternalControl: steptime=", steptime)
MULT_jointstate = {{JOINT_STATE_REPLACE}}
MULT_time = {{TIME_REPLACE}}

#Constants
SERVO_UNINITIALIZED = -1
SERVO_IDLE = 0
SERVO_RUNNING = 1

MODE_STOPPED = -2
MODE_UNINITIALIZED = -1
MODE_IDLE = 0
MODE_SERVOJ = 1
MODE_SPEEDJ = 2
MODE_FORWARD = 3
MODE_SPEEDL = 4
MODE_POSE = 5
MODE_FREEDRIVE = 6
MODE_TOOL_IN_CONTACT = 7
# Data dimensions of the message received on the reverse interface
REVERSE_INTERFACE_DATA_DIMENSION = 8

TRAJECTORY_MODE_RECEIVE = 1
TRAJECTORY_MODE_CANCEL = -1

TRAJECTORY_POINT_JOINT = 0
TRAJECTORY_POINT_CARTESIAN = 1
TRAJECTORY_DATA_DIMENSION = 7

TRAJECTORY_RESULT_SUCCESS = 0
TRAJECTORY_RESULT_CANCELED = 1
TRAJECTORY_RESULT_FAILURE = 2

ZERO_FTSENSOR = 0
SET_PAYLOAD = 1
SET_TOOL_VOLTAGE = 2
START_FORCE_MODE = 3
END_FORCE_MODE = 4
START_TOOL_CONTACT = 5
END_TOOL_CONTACT = 6
SCRIPT_COMMAND_DATA_DIMENSION = 26

FREEDRIVE_MODE_START = 1
FREEDRIVE_MODE_STOP = -1

UNTIL_TOOL_CONTACT_RESULT_SUCCESS = 0
UNTIL_TOOL_CONTACT_RESULT_CANCELED = 1

#Global variables are also showed in the Teach pendants variable list
global cmd_servo_state = SERVO_UNINITIALIZED
global cmd_servo_qd = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
global cmd_servo_q = get_actual_joint_positions()
global cmd_servo_q_last = get_actual_joint_positions()
global cmd_twist = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
global extrapolate_count = 0
global extrapolate_max_count = 0
global control_mode = MODE_UNINITIALIZED
global trajectory_points_left = 0
global tool_contact_running = False

# Global thread variables
thread_move = 0
thread_trajectory = 0
thread_script_commands = 0

def set_servo_setpoint(q):
  cmd_servo_state = SERVO_RUNNING
  cmd_servo_q_last = cmd_servo_q
  cmd_servo_q = q
end

def extrapolate():
  diff = [cmd_servo_q[0] - cmd_servo_q_last[0], cmd_servo_q[1] - cmd_servo_q_last[1], cmd_servo_q[2] - cmd_servo_q_last[2], cmd_servo_q[3] - cmd_servo_q_last[3], cmd_servo_q[4] - cmd_servo_q_last[4], cmd_servo_q[5] - cmd_servo_q_last[5]]
  cmd_servo_q_last = cmd_servo_q
  cmd_servo_q = [cmd_servo_q[0] + diff[0], cmd_servo_q[1] + diff[1], cmd_servo_q[2] + diff[2], cmd_servo_q[3] + diff[3], cmd_servo_q[4] + diff[4], cmd_servo_q[5] + diff[5]]

  return cmd_servo_q
end

thread servoThread():
  textmsg("ExternalControl: Starting servo thread")
  state = SERVO_IDLE
  while control_mode == MODE_SERVOJ:
    enter_critical
    q = cmd_servo_q
    do_extrapolate = False
    if (cmd_servo_state == SERVO_IDLE):
      do_extrapolate = True
    end
    state = cmd_servo_state
    if cmd_servo_state > SERVO_UNINITIALIZED:
      cmd_servo_state = SERVO_IDLE
    end

    if do_extrapolate:
      extrapolate_count = extrapolate_count + 1
      if extrapolate_count > extrapolate_max_count:
        extrapolate_max_count = extrapolate_count
      end

      q = extrapolate()
      servoj(q, t=steptime, {{SERVO_J_REPLACE}})

    elif state == SERVO_RUNNING:
      extrapolate_count = 0
      servoj(q, t=steptime, {{SERVO_J_REPLACE}})
    else:
      extrapolate_count = 0
      sync()
    end
    exit_critical
  end
  textmsg("ExternalControl: servo thread ended")
  stopj(4.0)
end

# Helpers for speed control
def set_speed(qd):
  cmd_servo_qd = qd
  control_mode = MODE_SPEEDJ
end

thread speedThread():
  textmsg("ExternalControl: Starting speed thread")
  while control_mode == MODE_SPEEDJ:
    qd = cmd_servo_qd
    speedj(qd, 40.0, steptime)
  end
  textmsg("ExternalControl: speedj thread ended")
  stopj(5.0)
end

thread jointTrajectoryThread():
  textmsg("Executing trajectory. Number of points: ", trajectory_points_left)
  while trajectory_points_left > 0:
    enter_critical
    #reading trajectory point + blend radius + type of point (cartesian/joint based)
    raw_point = socket_read_binary_integer(TRAJECTORY_DATA_DIMENSION+1+1, "trajectory_socket")
    trajectory_points_left = trajectory_points_left - 1
    exit_critical
    if raw_point[0] > 0:
      q = [ raw_point[1] / MULT_jointstate, raw_point[2] / MULT_jointstate, raw_point[3] / MULT_jointstate, raw_point[4] / MULT_jointstate, raw_point[5] / MULT_jointstate, raw_point[6] / MULT_jointstate]
      tmptime = raw_point[7] / MULT_time
      blend_radius = raw_point[8] / MULT_time

      if trajectory_points_left > 0:
        if raw_point[9] == TRAJECTORY_POINT_JOINT:
          # textmsg("Executing movej with blending")
          movej(q, t=tmptime, r=blend_radius)
        elif raw_point[9] == TRAJECTORY_POINT_CARTESIAN:
          # textmsg("Executing movel with blending")
          movel(p[q[0], q[1], q[2], q[3], q[4], q[5]], t=tmptime, r=blend_radius)
        end
      else:
        if raw_point[9] == TRAJECTORY_POINT_JOINT:
          # textmsg("Executing movej without blending")
          movej(q, t=tmptime, r=0.0)
        elif raw_point[9] == TRAJECTORY_POINT_CARTESIAN:
          # textmsg("Executing movel without blending")
          movel(p[q[0], q[1], q[2], q[3], q[4], q[5]], t=tmptime, r=0.0)
        end
      end
    end
  end
  socket_send_int(TRAJECTORY_RESULT_SUCCESS, "trajectory_socket")
  textmsg("Trajectory finished")
end

def clear_remaining_trajectory_points():
  while trajectory_points_left > 0:
    raw_point = socket_read_binary_integer(TRAJECTORY_DATA_DIMENSION+2, "trajectory_socket")
    trajectory_points_left = trajectory_points_left - 1
  end
end

# Helpers for speed control
def set_speedl(twist):
  cmd_twist = twist
  control_mode = MODE_SPEEDL
end

thread speedlThread():
  textmsg("Starting speedl thread")
  while control_mode == MODE_SPEEDL:
    twist = cmd_twist
    speedl(twist, 40.0, steptime)
  end
  textmsg("speedl thread ended")
  stopj(5.0)
end

thread servoThreadP():
  textmsg("Starting pose servo thread")
  state = SERVO_IDLE
  while control_mode == MODE_POSE:
    enter_critical
    q = cmd_servo_q
    do_extrapolate = False
    if (cmd_servo_state == SERVO_IDLE):
      do_extrapolate = True
    end
    state = cmd_servo_state
    if cmd_servo_state > SERVO_UNINITIALIZED:
      cmd_servo_state = SERVO_IDLE
    end

    if do_extrapolate:
      extrapolate_count = extrapolate_count + 1
      if extrapolate_count > extrapolate_max_count:
        extrapolate_max_count = extrapolate_count
      end

      q = extrapolate()
      servoj(q, t=steptime, {{SERVO_J_REPLACE}})

    elif state == SERVO_RUNNING:
      extrapolate_count = 0
      servoj(q, t=steptime, {{SERVO_J_REPLACE}})
    else:
      extrapolate_count = 0
      sync()
    end
    exit_critical
  end
  textmsg("pose servo thread ended")
  stopj(4.0)
end

def set_servo_pose(pose):
  cmd_servo_state = SERVO_RUNNING
  cmd_servo_q_last = cmd_servo_q
  cmd_servo_q = get_inverse_kin(pose, cmd_servo_q)
end

def tool_contact_detection():
  # Detect tool contact in the directions that the TCP is moving
  step_back = tool_contact(direction = get_actual_tcp_speed())

  # If tool contact is detected stop movement and move back to intial contact point
  if step_back > 0:
    if control_mode == MODE_FORWARD:
      kill thread_trajectory
      clear_remaining_trajectory_points()
    elif control_mode == MODE_FREEDRIVE:
      end_freedrive_mode()
    else:
      kill thread_move
    end

    # Set control mode to tool in contact, should be cleared by stopping tool contact detection
    control_mode = MODE_TOOL_IN_CONTACT
    stopl(3)

    # Move to initial contact point
    q = get_actual_joint_positions_history(step_back)
    movel(q)
    socket_send_int(UNTIL_TOOL_CONTACT_RESULT_SUCCESS, "script_command_socket")
    textmsg("tool contact detected")
  end
end

# Thread to receive one shot script commands, the commands shouldn't be blocking
thread script_commands():
  while control_mode > MODE_STOPPED:
    raw_command = socket_read_binary_integer(SCRIPT_COMMAND_DATA_DIMENSION, "script_command_socket", 0)
    if raw_command[0] > 0:
      command = raw_command[1]
      if command == ZERO_FTSENSOR:
        zero_ftsensor()
      elif command == SET_PAYLOAD:
        mass = raw_command[2] / MULT_jointstate
        cog = [raw_command[3] / MULT_jointstate, raw_command[4] / MULT_jointstate, raw_command[5] / MULT_jointstate]
        set_payload(mass, cog)
      elif command == SET_TOOL_VOLTAGE:
        tool_voltage = raw_command[2] / MULT_jointstate
        set_tool_voltage(tool_voltage)
      elif command == START_FORCE_MODE:
        task_frame = p[raw_command[2] / MULT_jointstate, raw_command[3] / MULT_jointstate, raw_command[4] / MULT_jointstate, raw_command[5] / MULT_jointstate, raw_command[6] / MULT_jointstate, raw_command[7] / MULT_jointstate]
        selection_vector = [raw_command[8] / MULT_jointstate, raw_command[9] / MULT_jointstate, raw_command[10] / MULT_jointstate, raw_command[11] / MULT_jointstate, raw_command[12] / MULT_jointstate, raw_command[13] / MULT_jointstate]
        wrench = [raw_command[14] / MULT_jointstate, raw_command[15] / MULT_jointstate, raw_command[16] / MULT_jointstate, raw_command[17] / MULT_jointstate, raw_command[18] / MULT_jointstate, raw_command[19] / MULT_jointstate]
        force_type = raw_command[20] / MULT_jointstate
        force_limits = [raw_command[21] / MULT_jointstate, raw_command[22] / MULT_jointstate, raw_command[23] / MULT_jointstate, raw_command[24] / MULT_jointstate, raw_command[25] / MULT_jointstate, raw_command[26] / MULT_jointstate]
        force_mode(task_frame, selection_vector, wrench, force_type, force_limits)
      elif command == END_FORCE_MODE:
        end_force_mode()
      elif command == START_TOOL_CONTACT:
        tool_contact_running = True
      elif command == END_TOOL_CONTACT:
        if control_mode != MODE_TOOL_IN_CONTACT:
          # If tool contact hasn't been detected send canceled result
          socket_send_int(UNTIL_TOOL_CONTACT_RESULT_CANCELED, "script_command_socket")
        end
        tool_contact_running = False
      end
    end
  end
end

# HEADER_END

# NODE_CONTROL_LOOP_BEGINS
socket_open("{{SERVER_IP_REPLACE}}", {{SERVER_PORT_REPLACE}}, "reverse_socket")
socket_open("{{SERVER_IP_REPLACE}}", {{TRAJECTORY_SERVER_PORT_REPLACE}}, "trajectory_socket")
socket_open("{{SERVER_IP_REPLACE}}", {{SCRIPT_COMMAND_SERVER_PORT_REPLACE}}, "script_command_socket")

force_mode_set_damping({{FORCE_MODE_SET_DAMPING_REPLACE}})
force_mode_set_gain_scaling({{FORCE_MODE_SET_GAIN_SCALING_REPLACE}})

control_mode = MODE_UNINITIALIZED
thread_move = 0
thread_trajectory = 0
trajectory_points_left = 0
global keepalive = -2
params_mult = socket_read_binary_integer(REVERSE_INTERFACE_DATA_DIMENSION, "reverse_socket", 0)
textmsg("ExternalControl: External control active")
keepalive = params_mult[1]
thread_script_commands = run script_commands()
while keepalive > 0 and control_mode > MODE_STOPPED:
  enter_critical
  params_mult = socket_read_binary_integer(REVERSE_INTERFACE_DATA_DIMENSION, "reverse_socket", 0.02) # steptime could work as well, but does not work in simulation
  if params_mult[0] > 0:
    keepalive = params_mult[1]
    if control_mode != params_mult[REVERSE_INTERFACE_DATA_DIMENSION]:
      # Clear remaining trajectory points
      if control_mode == MODE_FORWARD:
        kill thread_trajectory
        clear_remaining_trajectory_points()
      # Stop freedrive
      elif control_mode == MODE_FREEDRIVE:
        end_freedrive_mode()
      end

      # If tool is in contact, tool contact should be ended before switching control mode
      if control_mode == MODE_TOOL_IN_CONTACT:
        if tool_contact_running == False:
          control_mode = params_mult[REVERSE_INTERFACE_DATA_DIMENSION]
        end
      else:
        control_mode = params_mult[REVERSE_INTERFACE_DATA_DIMENSION]
        join thread_move
      end
      if control_mode == MODE_SERVOJ:
        thread_move = run servoThread()
      elif control_mode == MODE_SPEEDJ:
        thread_move = run speedThread()
      elif control_mode == MODE_FORWARD:
        kill thread_move
      elif control_mode == MODE_SPEEDL:
        thread_move = run speedlThread()
      elif control_mode == MODE_POSE:
        thread_move = run servoThreadP()
      end
    end
    if control_mode == MODE_SERVOJ:
      q = [params_mult[2] / MULT_jointstate, params_mult[3] / MULT_jointstate, params_mult[4] / MULT_jointstate, params_mult[5] / MULT_jointstate, params_mult[6] / MULT_jointstate, params_mult[7] / MULT_jointstate]
      set_servo_setpoint(q)
    elif control_mode == MODE_SPEEDJ:
      qd = [params_mult[2] / MULT_jointstate, params_mult[3] / MULT_jointstate, params_mult[4] / MULT_jointstate, params_mult[5] / MULT_jointstate, params_mult[6] / MULT_jointstate, params_mult[7] / MULT_jointstate]
      set_speed(qd)
    elif control_mode == MODE_FORWARD:
      if params_mult[2] == TRAJECTORY_MODE_RECEIVE:
        kill thread_trajectory
        clear_remaining_trajectory_points()
        trajectory_points_left = params_mult[3]
        thread_trajectory = run jointTrajectoryThread()
      elif params_mult[2] == TRAJECTORY_MODE_CANCEL:
        textmsg("cancel received")
        kill thread_trajectory
        clear_remaining_trajectory_points()
        socket_send_int(TRAJECTORY_RESULT_CANCELED, "trajectory_socket")
      end
    elif control_mode == MODE_SPEEDL:
      twist = [params_mult[2] / MULT_jointstate, params_mult[3] / MULT_jointstate, params_mult[4] / MULT_jointstate, params_mult[5] / MULT_jointstate, params_mult[6] / MULT_jointstate, params_mult[7] / MULT_jointstate]
      set_speedl(twist)
    elif control_mode == MODE_POSE:
      pose = p[params_mult[2] / MULT_jointstate, params_mult[3] / MULT_jointstate, params_mult[4] / MULT_jointstate, params_mult[5] / MULT_jointstate, params_mult[6] / MULT_jointstate, params_mult[7] / MULT_jointstate]
      set_servo_pose(pose)
    elif control_mode == MODE_FREEDRIVE:
      if params_mult[2] == FREEDRIVE_MODE_START:
        freedrive_mode()
      elif params_mult[2] == FREEDRIVE_MODE_STOP:
        end_freedrive_mode()
      end
    end
    # Tool contact is running, but hasn't been detected
    if tool_contact_running == True and control_mode != MODE_TOOL_IN_CONTACT:
      tool_contact_detection()
    end
  else:
    keepalive = keepalive - 1
  end
  exit_critical
end

textmsg("ExternalControl: Stopping communication and control")
control_mode = MODE_STOPPED
join thread_move
join thread_trajectory
kill thread_script_commands
join thread_script_commands
textmsg("ExternalControl: All threads ended")
socket_close("reverse_socket")
socket_close("trajectory_socket")
socket_close("script_command_socket")

# NODE_CONTROL_LOOP_ENDS
